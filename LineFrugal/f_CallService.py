#
# Autogenerated by Frugal Compiler (3.16.5)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



import asyncio
from datetime import timedelta
import inspect

from frugal.aio.processor import FBaseProcessor
from frugal.aio.processor import FProcessorFunction
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.middleware import Method
from frugal.transport import TMemoryOutputBuffer
from frugal.util.deprecate import deprecated
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException
from .ttypes import *


class Iface(object):

    async def getGroupCall(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        pass

    async def inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            mediaType: MediaType
        """
        pass

    async def acquireCallRoute(self, ctx, to, callType, fromEnvInfo):
        """
        Args:
            ctx: FContext
            to: string
            callType: CallType
            fromEnvInfo: dict of <string, string>
        """
        pass

    async def acquireGroupCallRoute(self, ctx, chatMid, mediaType, isInitialHost, capabilities):
        """
        Args:
            ctx: FContext
            chatMid: string
            mediaType: MediaType
            isInitialHost: boolean
            capabilities: list of string
        """
        pass

    async def acquireOACallRoute(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: AcquireOACallRouteRequest
        """
        pass

    async def acquireTestCallRoute(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def getPaidCallBalanceList(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        pass

    async def searchPaidCallUserRate(self, ctx, countryCode, language):
        """
        Args:
            ctx: FContext
            countryCode: string
            language: string
        """
        pass

    async def updateGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: UpdateGroupCallUrlRequest
        """
        pass

    async def getGroupCallUrls(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: GetGroupCallUrlsRequest
        """
        pass

    async def getGroupCallUrlInfo(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: GetGroupCallUrlInfoRequest
        """
        pass

    async def deleteGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: DeleteGroupCallUrlRequest
        """
        pass

    async def kickoutFromGroupCall(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: KickoutFromGroupCallRequest
        """
        pass

    async def createGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CreateGroupCallUrlRequest
        """
        pass

    async def joinChatByCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: JoinChatByCallUrlRequest
        """
        pass


class Client(Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        self._transport = provider.get_transport()
        self._protocol_factory = provider.get_protocol_factory()
        middleware += provider.get_middleware()
        self._methods = {
            'getGroupCall': Method(self._getGroupCall, middleware),
            'inviteIntoGroupCall': Method(self._inviteIntoGroupCall, middleware),
            'acquireCallRoute': Method(self._acquireCallRoute, middleware),
            'acquireGroupCallRoute': Method(self._acquireGroupCallRoute, middleware),
            'acquireOACallRoute': Method(self._acquireOACallRoute, middleware),
            'acquireTestCallRoute': Method(self._acquireTestCallRoute, middleware),
            'getPaidCallBalanceList': Method(self._getPaidCallBalanceList, middleware),
            'searchPaidCallUserRate': Method(self._searchPaidCallUserRate, middleware),
            'updateGroupCallUrl': Method(self._updateGroupCallUrl, middleware),
            'getGroupCallUrls': Method(self._getGroupCallUrls, middleware),
            'getGroupCallUrlInfo': Method(self._getGroupCallUrlInfo, middleware),
            'deleteGroupCallUrl': Method(self._deleteGroupCallUrl, middleware),
            'kickoutFromGroupCall': Method(self._kickoutFromGroupCall, middleware),
            'createGroupCallUrl': Method(self._createGroupCallUrl, middleware),
            'joinChatByCallUrl': Method(self._joinChatByCallUrl, middleware),
        }

    async def getGroupCall(self, ctx, chatMid):
        """
        Args:
            ctx: FContext
            chatMid: string
        """
        return await self._methods['getGroupCall']([ctx, chatMid])

    async def _getGroupCall(self, ctx, chatMid):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getGroupCall', TMessageType.CALL, 0)
        args = getGroupCall_args()
        args.chatMid = chatMid
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupCall failed: unknown result")

    async def inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        """
        Args:
            ctx: FContext
            chatMid: string
            memberMids: list of string
            mediaType: MediaType
        """
        return await self._methods['inviteIntoGroupCall']([ctx, chatMid, memberMids, mediaType])

    async def _inviteIntoGroupCall(self, ctx, chatMid, memberMids, mediaType):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('inviteIntoGroupCall', TMessageType.CALL, 0)
        args = inviteIntoGroupCall_args()
        args.chatMid = chatMid
        args.memberMids = memberMids
        args.mediaType = mediaType
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = inviteIntoGroupCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
    async def acquireCallRoute(self, ctx, to, callType, fromEnvInfo):
        """
        Args:
            ctx: FContext
            to: string
            callType: CallType
            fromEnvInfo: dict of <string, string>
        """
        return await self._methods['acquireCallRoute']([ctx, to, callType, fromEnvInfo])

    async def _acquireCallRoute(self, ctx, to, callType, fromEnvInfo):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('acquireCallRoute', TMessageType.CALL, 0)
        args = acquireCallRoute_args()
        args.to = to
        args.callType = callType
        args.fromEnvInfo = fromEnvInfo
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireCallRoute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireCallRoute failed: unknown result")

    async def acquireGroupCallRoute(self, ctx, chatMid, mediaType, isInitialHost, capabilities):
        """
        Args:
            ctx: FContext
            chatMid: string
            mediaType: MediaType
            isInitialHost: boolean
            capabilities: list of string
        """
        return await self._methods['acquireGroupCallRoute']([ctx, chatMid, mediaType, isInitialHost, capabilities])

    async def _acquireGroupCallRoute(self, ctx, chatMid, mediaType, isInitialHost, capabilities):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('acquireGroupCallRoute', TMessageType.CALL, 0)
        args = acquireGroupCallRoute_args()
        args.chatMid = chatMid
        args.mediaType = mediaType
        args.isInitialHost = isInitialHost
        args.capabilities = capabilities
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireGroupCallRoute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireGroupCallRoute failed: unknown result")

    async def acquireOACallRoute(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: AcquireOACallRouteRequest
        """
        return await self._methods['acquireOACallRoute']([ctx, request])

    async def _acquireOACallRoute(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('acquireOACallRoute', TMessageType.CALL, 0)
        args = acquireOACallRoute_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireOACallRoute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireOACallRoute failed: unknown result")

    async def acquireTestCallRoute(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return await self._methods['acquireTestCallRoute']([ctx])

    async def _acquireTestCallRoute(self, ctx):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('acquireTestCallRoute', TMessageType.CALL, 0)
        args = acquireTestCallRoute_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = acquireTestCallRoute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "acquireTestCallRoute failed: unknown result")

    async def getPaidCallBalanceList(self, ctx, language):
        """
        Args:
            ctx: FContext
            language: string
        """
        return await self._methods['getPaidCallBalanceList']([ctx, language])

    async def _getPaidCallBalanceList(self, ctx, language):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getPaidCallBalanceList', TMessageType.CALL, 0)
        args = getPaidCallBalanceList_args()
        args.language = language
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getPaidCallBalanceList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getPaidCallBalanceList failed: unknown result")

    async def searchPaidCallUserRate(self, ctx, countryCode, language):
        """
        Args:
            ctx: FContext
            countryCode: string
            language: string
        """
        return await self._methods['searchPaidCallUserRate']([ctx, countryCode, language])

    async def _searchPaidCallUserRate(self, ctx, countryCode, language):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('searchPaidCallUserRate', TMessageType.CALL, 0)
        args = searchPaidCallUserRate_args()
        args.countryCode = countryCode
        args.language = language
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = searchPaidCallUserRate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "searchPaidCallUserRate failed: unknown result")

    async def updateGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: UpdateGroupCallUrlRequest
        """
        return await self._methods['updateGroupCallUrl']([ctx, request])

    async def _updateGroupCallUrl(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('updateGroupCallUrl', TMessageType.CALL, 0)
        args = updateGroupCallUrl_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = updateGroupCallUrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "updateGroupCallUrl failed: unknown result")

    async def getGroupCallUrls(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: GetGroupCallUrlsRequest
        """
        return await self._methods['getGroupCallUrls']([ctx, request])

    async def _getGroupCallUrls(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getGroupCallUrls', TMessageType.CALL, 0)
        args = getGroupCallUrls_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupCallUrls_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupCallUrls failed: unknown result")

    async def getGroupCallUrlInfo(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: GetGroupCallUrlInfoRequest
        """
        return await self._methods['getGroupCallUrlInfo']([ctx, request])

    async def _getGroupCallUrlInfo(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getGroupCallUrlInfo', TMessageType.CALL, 0)
        args = getGroupCallUrlInfo_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getGroupCallUrlInfo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getGroupCallUrlInfo failed: unknown result")

    async def deleteGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: DeleteGroupCallUrlRequest
        """
        return await self._methods['deleteGroupCallUrl']([ctx, request])

    async def _deleteGroupCallUrl(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('deleteGroupCallUrl', TMessageType.CALL, 0)
        args = deleteGroupCallUrl_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = deleteGroupCallUrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "deleteGroupCallUrl failed: unknown result")

    async def kickoutFromGroupCall(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: KickoutFromGroupCallRequest
        """
        return await self._methods['kickoutFromGroupCall']([ctx, request])

    async def _kickoutFromGroupCall(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('kickoutFromGroupCall', TMessageType.CALL, 0)
        args = kickoutFromGroupCall_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = kickoutFromGroupCall_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "kickoutFromGroupCall failed: unknown result")

    async def createGroupCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: CreateGroupCallUrlRequest
        """
        return await self._methods['createGroupCallUrl']([ctx, request])

    async def _createGroupCallUrl(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('createGroupCallUrl', TMessageType.CALL, 0)
        args = createGroupCallUrl_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = createGroupCallUrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "createGroupCallUrl failed: unknown result")

    async def joinChatByCallUrl(self, ctx, request):
        """
        Args:
            ctx: FContext
            request: JoinChatByCallUrlRequest
        """
        return await self._methods['joinChatByCallUrl']([ctx, request])

    async def _joinChatByCallUrl(self, ctx, request):
        memory_buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(memory_buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('joinChatByCallUrl', TMessageType.CALL, 0)
        args = joinChatByCallUrl_args()
        args.request = request
        args.write(oprot)
        oprot.writeMessageEnd()
        response_transport = await self._transport.request(ctx, memory_buffer.getvalue())

        iprot = self._protocol_factory.get_protocol(response_transport)
        iprot.read_response_headers(ctx)
        _, mtype, _ = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = joinChatByCallUrl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationExceptionType.MISSING_RESULT, "joinChatByCallUrl failed: unknown result")


class Processor(FBaseProcessor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__()
        self.add_to_processor_map('getGroupCall', _getGroupCall(Method(handler.getGroupCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('inviteIntoGroupCall', _inviteIntoGroupCall(Method(handler.inviteIntoGroupCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireCallRoute', _acquireCallRoute(Method(handler.acquireCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireGroupCallRoute', _acquireGroupCallRoute(Method(handler.acquireGroupCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireOACallRoute', _acquireOACallRoute(Method(handler.acquireOACallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('acquireTestCallRoute', _acquireTestCallRoute(Method(handler.acquireTestCallRoute, middleware), self.get_write_lock()))
        self.add_to_processor_map('getPaidCallBalanceList', _getPaidCallBalanceList(Method(handler.getPaidCallBalanceList, middleware), self.get_write_lock()))
        self.add_to_processor_map('searchPaidCallUserRate', _searchPaidCallUserRate(Method(handler.searchPaidCallUserRate, middleware), self.get_write_lock()))
        self.add_to_processor_map('updateGroupCallUrl', _updateGroupCallUrl(Method(handler.updateGroupCallUrl, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupCallUrls', _getGroupCallUrls(Method(handler.getGroupCallUrls, middleware), self.get_write_lock()))
        self.add_to_processor_map('getGroupCallUrlInfo', _getGroupCallUrlInfo(Method(handler.getGroupCallUrlInfo, middleware), self.get_write_lock()))
        self.add_to_processor_map('deleteGroupCallUrl', _deleteGroupCallUrl(Method(handler.deleteGroupCallUrl, middleware), self.get_write_lock()))
        self.add_to_processor_map('kickoutFromGroupCall', _kickoutFromGroupCall(Method(handler.kickoutFromGroupCall, middleware), self.get_write_lock()))
        self.add_to_processor_map('createGroupCallUrl', _createGroupCallUrl(Method(handler.createGroupCallUrl, middleware), self.get_write_lock()))
        self.add_to_processor_map('joinChatByCallUrl', _joinChatByCallUrl(Method(handler.joinChatByCallUrl, middleware), self.get_write_lock()))


class _getGroupCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupCall, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = getGroupCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupCall_result()
        try:
            ret = self._handler([ctx, args.chatMid])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCall", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _inviteIntoGroupCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_inviteIntoGroupCall, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = inviteIntoGroupCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = inviteIntoGroupCall_result()
        try:
            ret = self._handler([ctx, args.chatMid, args.memberMids, args.mediaType])
            if inspect.iscoroutine(ret):
                ret = await ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroupCall", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "inviteIntoGroupCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('inviteIntoGroupCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "inviteIntoGroupCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _acquireCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireCallRoute, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = acquireCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireCallRoute_result()
        try:
            ret = self._handler([ctx, args.to, args.callType, args.fromEnvInfo])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallRoute", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _acquireGroupCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireGroupCallRoute, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = acquireGroupCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireGroupCallRoute_result()
        try:
            ret = self._handler([ctx, args.chatMid, args.mediaType, args.isInitialHost, args.capabilities])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireGroupCallRoute", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireGroupCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireGroupCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireGroupCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _acquireOACallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireOACallRoute, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = acquireOACallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireOACallRoute_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireOACallRoute", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireOACallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireOACallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireOACallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _acquireTestCallRoute(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_acquireTestCallRoute, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = acquireTestCallRoute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = acquireTestCallRoute_result()
        try:
            ret = self._handler([ctx])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireTestCallRoute", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "acquireTestCallRoute", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('acquireTestCallRoute', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "acquireTestCallRoute", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getPaidCallBalanceList(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getPaidCallBalanceList, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = getPaidCallBalanceList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPaidCallBalanceList_result()
        try:
            ret = self._handler([ctx, args.language])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallBalanceList", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getPaidCallBalanceList", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getPaidCallBalanceList', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getPaidCallBalanceList", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _searchPaidCallUserRate(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_searchPaidCallUserRate, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = searchPaidCallUserRate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = searchPaidCallUserRate_result()
        try:
            ret = self._handler([ctx, args.countryCode, args.language])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "searchPaidCallUserRate", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "searchPaidCallUserRate", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('searchPaidCallUserRate', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "searchPaidCallUserRate", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _updateGroupCallUrl(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_updateGroupCallUrl, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = updateGroupCallUrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateGroupCallUrl_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "updateGroupCallUrl", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "updateGroupCallUrl", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('updateGroupCallUrl', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "updateGroupCallUrl", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getGroupCallUrls(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupCallUrls, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = getGroupCallUrls_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupCallUrls_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCallUrls", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCallUrls", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupCallUrls', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupCallUrls", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _getGroupCallUrlInfo(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getGroupCallUrlInfo, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = getGroupCallUrlInfo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getGroupCallUrlInfo_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCallUrlInfo", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "getGroupCallUrlInfo", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getGroupCallUrlInfo', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getGroupCallUrlInfo", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _deleteGroupCallUrl(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_deleteGroupCallUrl, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = deleteGroupCallUrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteGroupCallUrl_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "deleteGroupCallUrl", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "deleteGroupCallUrl", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('deleteGroupCallUrl', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "deleteGroupCallUrl", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _kickoutFromGroupCall(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_kickoutFromGroupCall, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = kickoutFromGroupCall_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = kickoutFromGroupCall_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "kickoutFromGroupCall", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "kickoutFromGroupCall", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('kickoutFromGroupCall', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "kickoutFromGroupCall", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _createGroupCallUrl(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_createGroupCallUrl, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = createGroupCallUrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = createGroupCallUrl_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "createGroupCallUrl", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "createGroupCallUrl", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('createGroupCallUrl', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "createGroupCallUrl", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


class _joinChatByCallUrl(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_joinChatByCallUrl, self).__init__(handler, lock)

    async def process(self, ctx, iprot, oprot):
        args = joinChatByCallUrl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = joinChatByCallUrl_result()
        try:
            ret = self._handler([ctx, args.request])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except TApplicationException as ex:
            async with self._lock:
                _write_application_exception(ctx, oprot, "joinChatByCallUrl", exception=ex)
                return
        except TalkException as e:
            result.e = e
        except Exception as e:
            async with self._lock:
                _write_application_exception(ctx, oprot, "joinChatByCallUrl", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=str(e))
            raise
        async with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('joinChatByCallUrl', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "joinChatByCallUrl", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.message)
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class getGroupCall_args(object):
    """
    Attributes:
     - chatMid
    """
    def __init__(self, chatMid=None):
        self.chatMid = chatMid

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCall_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCall_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GroupCall()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCall_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroupCall_args(object):
    """
    Attributes:
     - chatMid
     - memberMids
     - mediaType
    """
    def __init__(self, chatMid=None, memberMids=None, mediaType=None):
        self.chatMid = chatMid
        self.memberMids = memberMids
        self.mediaType = mediaType

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.memberMids = []
                    (_, elem385) = iprot.readListBegin()
                    for _ in range(elem385):
                        elem386 = iprot.readString()
                        self.memberMids.append(elem386)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.mediaType = MediaType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroupCall_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        if self.memberMids is not None:
            oprot.writeFieldBegin('memberMids', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.memberMids))
            for elem387 in self.memberMids:
                oprot.writeString(elem387)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.mediaType is not None:
            oprot.writeFieldBegin('mediaType', TType.I32, 4)
            oprot.writeI32(self.mediaType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        value = (value * 31) ^ hash(make_hashable(self.memberMids))
        value = (value * 31) ^ hash(make_hashable(self.mediaType))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class inviteIntoGroupCall_result(object):
    """
    Attributes:
     - e
    """
    def __init__(self, e=None):
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('inviteIntoGroupCall_result')
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallRoute_args(object):
    """
    Attributes:
     - to
     - callType
     - fromEnvInfo
    """
    def __init__(self, to=None, callType=None, fromEnvInfo=None):
        self.to = to
        self.callType = callType
        self.fromEnvInfo = fromEnvInfo

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.to = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.callType = CallType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.fromEnvInfo = {}
                    (_, _, elem388) = iprot.readMapBegin()
                    for _ in range(elem388):
                        elem390 = iprot.readString()
                        elem389 = iprot.readString()
                        self.fromEnvInfo[elem390] = elem389
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallRoute_args')
        if self.to is not None:
            oprot.writeFieldBegin('to', TType.STRING, 2)
            oprot.writeString(self.to)
            oprot.writeFieldEnd()
        if self.callType is not None:
            oprot.writeFieldBegin('callType', TType.I32, 3)
            oprot.writeI32(self.callType)
            oprot.writeFieldEnd()
        if self.fromEnvInfo is not None:
            oprot.writeFieldBegin('fromEnvInfo', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.fromEnvInfo))
            for elem392, elem391 in self.fromEnvInfo.items():
                oprot.writeString(elem392)
                oprot.writeString(elem391)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.to))
        value = (value * 31) ^ hash(make_hashable(self.callType))
        value = (value * 31) ^ hash(make_hashable(self.fromEnvInfo))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CallRoute()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireGroupCallRoute_args(object):
    """
    Attributes:
     - chatMid
     - mediaType
     - isInitialHost
     - capabilities
    """
    def __init__(self, chatMid=None, mediaType=None, isInitialHost=None, capabilities=None):
        self.chatMid = chatMid
        self.mediaType = mediaType
        self.isInitialHost = isInitialHost
        self.capabilities = capabilities

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.chatMid = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mediaType = MediaType(iprot.readI32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isInitialHost = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.capabilities = []
                    (_, elem393) = iprot.readListBegin()
                    for _ in range(elem393):
                        elem394 = iprot.readString()
                        self.capabilities.append(elem394)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireGroupCallRoute_args')
        if self.chatMid is not None:
            oprot.writeFieldBegin('chatMid', TType.STRING, 2)
            oprot.writeString(self.chatMid)
            oprot.writeFieldEnd()
        if self.mediaType is not None:
            oprot.writeFieldBegin('mediaType', TType.I32, 3)
            oprot.writeI32(self.mediaType)
            oprot.writeFieldEnd()
        if self.isInitialHost is not None:
            oprot.writeFieldBegin('isInitialHost', TType.BOOL, 4)
            oprot.writeBool(self.isInitialHost)
            oprot.writeFieldEnd()
        if self.capabilities is not None:
            oprot.writeFieldBegin('capabilities', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.capabilities))
            for elem395 in self.capabilities:
                oprot.writeString(elem395)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.chatMid))
        value = (value * 31) ^ hash(make_hashable(self.mediaType))
        value = (value * 31) ^ hash(make_hashable(self.isInitialHost))
        value = (value * 31) ^ hash(make_hashable(self.capabilities))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireGroupCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GroupCallRoute()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireGroupCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireOACallRoute_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = AcquireOACallRouteRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireOACallRoute_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireOACallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AcquireOACallRouteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireOACallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireTestCallRoute_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireTestCallRoute_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class acquireTestCallRoute_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TestCallRoute()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('acquireTestCallRoute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallBalanceList_args(object):
    """
    Attributes:
     - language
    """
    def __init__(self, language=None):
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallBalanceList_args')
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 2)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getPaidCallBalanceList_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem396) = iprot.readListBegin()
                    for _ in range(elem396):
                        elem397 = PaidCallBalance()
                        elem397.read(iprot)
                        self.success.append(elem397)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getPaidCallBalanceList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem398 in self.success:
                elem398.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class searchPaidCallUserRate_args(object):
    """
    Attributes:
     - countryCode
     - language
    """
    def __init__(self, countryCode=None, language=None):
        self.countryCode = countryCode
        self.language = language

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRING:
                    self.countryCode = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.language = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('searchPaidCallUserRate_args')
        if self.countryCode is not None:
            oprot.writeFieldBegin('countryCode', TType.STRING, 2)
            oprot.writeString(self.countryCode)
            oprot.writeFieldEnd()
        if self.language is not None:
            oprot.writeFieldBegin('language', TType.STRING, 3)
            oprot.writeString(self.language)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.countryCode))
        value = (value * 31) ^ hash(make_hashable(self.language))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class searchPaidCallUserRate_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem399) = iprot.readListBegin()
                    for _ in range(elem399):
                        elem400 = PaidCallUserRate()
                        elem400.read(iprot)
                        self.success.append(elem400)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('searchPaidCallUserRate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for elem401 in self.success:
                elem401.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroupCallUrl_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = UpdateGroupCallUrlRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroupCallUrl_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class updateGroupCallUrl_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = UpdateGroupCallUrlResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('updateGroupCallUrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCallUrls_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = GetGroupCallUrlsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCallUrls_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCallUrls_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupCallUrlsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCallUrls_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCallUrlInfo_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = GetGroupCallUrlInfoRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCallUrlInfo_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getGroupCallUrlInfo_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetGroupCallUrlInfoResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getGroupCallUrlInfo_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class deleteGroupCallUrl_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = DeleteGroupCallUrlRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('deleteGroupCallUrl_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class deleteGroupCallUrl_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DeleteGroupCallUrlResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('deleteGroupCallUrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class kickoutFromGroupCall_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = KickoutFromGroupCallRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('kickoutFromGroupCall_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class kickoutFromGroupCall_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = KickoutFromGroupCallResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('kickoutFromGroupCall_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createGroupCallUrl_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = CreateGroupCallUrlRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createGroupCallUrl_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class createGroupCallUrl_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CreateGroupCallUrlResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('createGroupCallUrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class joinChatByCallUrl_args(object):
    """
    Attributes:
     - request
    """
    def __init__(self, request=None):
        self.request = request

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.STRUCT:
                    self.request = JoinChatByCallUrlRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('joinChatByCallUrl_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 2)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.request))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class joinChatByCallUrl_result(object):
    """
    Attributes:
     - success
     - e
    """
    def __init__(self, success=None, e=None):
        self.success = success
        self.e = e

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = JoinChatByCallUrlResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TalkException()
                    self.e.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('joinChatByCallUrl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin('e', TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.e))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

